# 每个 web 开发人员都应该知道的 CPU Arch，第 1 部分:线程与进程

> 原文:[https://www . moes if . com/blog/technical/CPU-Arch/What-Every-Every-Web-Developer-Should-Know-on-CPU-Arch-part 1/](https://www.moesif.com/blog/technical/cpu-arch/What-Every-Web-Developer-Should-Know-About-CPU-Arch-Part1/)

### 介绍

有很多讨论软件开发范例和最佳实践的博客文章，也有一些是关于硬件的。与此同时，从计算机体系结构的角度来看，讨论每个开发人员应该知道什么的文章的数量我一只手就能数出来。本文的目标不是深入探究 CPU 架构、操作系统等。我将概述一些原则，这些原则是我们作为开发人员在繁忙的日子里可以放松的。

### 线程与进程

#### 安全性和可靠性

在 Docker 容器和 VM 出现之前，CPU 硬件有一个最古老的沙盒技巧:进程和虚拟内存。作为开发人员，您应该明白，一个进程将在它自己的隔离内存空间中运行，并且只能通过特定的机制(如进程间通信(IPC))与其他进程对话。因此，如果您有进程 A 和进程 B，并且它们都有一个逻辑地址 0x0，那么它们实际上指向物理内存中两个独立的区域。现代 CPU 硬件通过分页提供安全保护，确保进程只能从自己的内存空间读写。常见的分段错误实际上最初是由 CPU 硬件通过一个 [#PF(页面错误)](https://en.wikipedia.org/wiki/Page_fault)由于非法访问而触发的。(注意:我将省略 x86 分段，因为分段寄存器在 64 位模式下不再真正“使用”)。

另一方面，同一进程中的线程共享相同的地址空间。访问同一个地址空间可能是好事也可能是坏事。如果线程崩溃，应用程序的状态可能是未知的。硬件中没有安全保护来防止流氓线程以非预期的方式访问其他线程的数据。事实上，Chrome 开始在自己的进程中运行每个浏览器标签，而不是仅仅使用多线程。如果你曾经在 Chrome 标签中看到“哦，Snap…”的话，那是一个无意中执行了某些东西的过程。失败的选项卡崩溃并且不再运行，但是剩余的选项卡可以照常继续工作。

#### 这不是意味着进程必须在内存中复制代码和数据吗？

是也不是。现代操作系统和硬件可以用一种叫做[写时复制(COW)](https://en.wikipedia.org/wiki/Copy-on-write) 的东西做一些聪明的事情。当您在 Linux 中调用 fork()时，最初并不是所有内容都被复制到内存空间的一个新部分。确保进程不会写入进程外内存空间的同一个分页硬件也可以在写入标记为只读的页面时抛出#PF。此标志允许操作系统处理故障，这意味着如果需要，将旧页面复制到内存中的新页面。

#### 使用进程不需要缓慢的上下文切换吗？

是的，进程需要上下文切换，但是线程也需要。一个线程还具有附加到它的执行上下文，它由它的各种 [CPU 寄存器值](https://cs.brown.edu/courses/cs033/docs/api-guide/x64_cheatsheet.pdf)(例如 x86 中的 EAX、EBX…)组成，在下一个线程可以开始执行之前需要存储其他内容。事实上，现代 SIMD 编码，如许多视频编码和压缩算法，以观看您最喜爱的高清网飞节目，使用一些相当大的寄存器，需要写入内存。事实上，AVX 的最新版本由 32 个 64 字节宽的寄存器组成！当提到进程比线程慢时，通常指的不仅仅是上下文切换本身，而是刷新[翻译后备缓冲器(TLB)](https://en.wikipedia.org/wiki/Translation_lookaside_buffer)中的条目。TLBs 保存了我们前面提到的分页机制的缓存翻译。因为一个新进程将在它自己的内存空间中执行，所以它不能使用旧进程的翻译，并将重新开始。这意味着 TLB 对新的工艺将会冷淡。如果翻译不在 TLB 中，则在存储器访问完成之前，页面未命中处理器(PMH)需要逐级遍历页面表。页表遍历是繁重的指针追踪算法，可以降低加载延迟。有一些捷径可以最大限度地减少行走所需的关卡数量，但最终的问题是寒冷的 TLB 会导致加载延迟远远大于温暖的 TLB。即使被访问的变量已经在某个地方的 CPU 缓存中，也会发生这种情况(我们将在后面讨论)

所以最终的结论是，流程的上下文切换可能不会太长，但是可能会有延迟的影响，甚至会降低后上下文的速度。

#### 线程太多。

在这个寒冷的 TLB，过程并不是唯一可以忍受的东西。如果线程没有被调度在同一个逻辑 CPU 上(CPU 亲缘关系)，也可以经历这种情况。这引出了下一个问题:应用程序可以运行的逻辑 CPU 数量是固定的。虽然现代操作系统有许多进程和线程可以在各种阻塞和等待状态下同时运行，但实际上 CPU 一次只能运行固定数量的线程。无论线程是否在同一个进程中，都是如此。当你启动更多的线程，然后你可以积极地运行，操作系统必须抢先上下文切换。如果您只是为每个任务生成一个又一个线程，认为它将全部并行运行，您可能会惊讶地发现，与在一个线程池中运行少量线程相比，您对性能的损害可能更大。

一般来说，大量线程会导致系统颠簸。系统颠簸是一个通用术语，当 CPU 开始交换或移动资源而不是执行实际执行时使用。CPU 的资源大小是有限的，TLB、高速缓存、甚至内存中分配的页表都是有限的。当您开始在更多线程之间切换时，您可能会给这些子系统带来压力，导致仍然热的数据被驱逐，这对性能是有害的。默认情况下，许多异步 web 框架被配置为将它们的工作线程池与逻辑核心的实际数量相匹配，或者它们可以添加一些额外的阻塞，但仍然在一个数量级内。想想优步的司机。有时候，让长途旅行的乘客上车，开一会儿车，然后不断地让新乘客上车，让老乘客下车，会更容易、更快捷。乘客数量是您的固定资源，如逻辑处理器、缓存大小和 TLB。如果你接了新乘客，你必须先赶走老乘客，为新乘客腾出空间。如果您开始发现自己在等待卸载和装载，而不仅仅是驾驶(工作或执行)，这种进出行为就是颠簸。

#### 第二部分

这是较长系列的第 1 部分，请继续关注下一部分

#### 谢谢

我们感谢我们的精选测试版客户，他们一直在试用 Moesif，为我们提供了宝贵的反馈，使调试变得更加容易。
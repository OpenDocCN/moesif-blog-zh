# 每个 API 团队都应该知道的 10 大 API 安全威胁

> 原文：<https://www.moesif.com/blog/technical/api-security/API-Security-Threats-Every-API-Team-Should-Know/>

随着越来越多的数据通过 API 公开，无论是作为 API 第一公司，还是作为单页应用/JAMStack 的爆发，API 安全性不再是事后的想法。API 的难点在于它提供了对大量数据的直接访问，同时绕过了浏览器的防范措施。你不应该担心 SQL 注入和 XSS 的问题，你应该担心的是那个能够对你所有的客户记录和数据进行分页的坏人。

像验证码和浏览器指纹这样的典型预防机制将不起作用，因为 API 的设计需要处理非常大量的 API 访问，即使是单个客户。那么你从哪里开始呢？第一件事是把你自己放在黑客的位置上，然后装备你的 API 来检测和阻止常见的攻击以及未知的零日攻击。其中一些在 [OWASP 安全 API 列表](https://owasp.org/www-project-api-security/)中，但不是全部。

## 不安全的分页和资源限制

大多数 API 提供对资源的访问，这些资源是实体的列表，如`/users`或`/widgets`。客户端(如浏览器)通常会对该列表进行过滤和分页，以限制返回给客户端的项目数量，如下所示:

```py
First Call: GET /items?skip=0&take=10

Second Call: GET /items?skip=10&take=10 
```

但是，如果该实体有任何 PII 或其他信息，那么黑客可以抓取该端点来获得数据库中所有实体的转储。如果这些实体意外暴露了 PII 或其他敏感信息，这可能是最危险的，但在向竞争对手或其他人提供您企业的采用和使用统计数据或向骗子提供获取大量电子邮件列表的方法时，这也是很危险的。[查看 Venmo 数据如何报废](https://22-8miles.com/public-by-default/)

一种简单的保护机制是检查获取计数，如果大于 100 或 1000 就抛出一个错误。这个问题有两个方面:

1.  对于数据 API，合法客户可能需要获取和同步大量记录，比如通过 cron 作业。人为的小分页限制会迫使您的 API 变得非常繁琐，从而降低整体吞吐量。最大限制是为了确保满足内存和可扩展性要求(并防止某些 DDoS 攻击)，而不是为了保证安全性。
2.  这对于编写简单脚本、在重复访问之间随机延迟休眠的黑客来说没有任何保护。

```py
skip = 0
while True:
    response = requests.post('https://api.acmeinc.com/widgets?take=10&skip=' + skip),
                      headers={'Authorization': 'Bearer' + ' ' + sys.argv[1]})
    print("Fetched 10 items")
    sleep(randint(100,1000))
    skip += 10 
```

### 如何防范分页攻击

为了防止分页攻击，您应该跟踪在特定时间段内每个用户或 API 键访问了单个资源的多少项，而不仅仅是在请求级别。[通过在用户级别](https://www.moesif.com/solutions/api-security)跟踪 API 资源访问，您可以在用户或 API 键达到某个阈值(如“一小时内接触了 1，000，000 个项目”)时阻止它们。这取决于您的 API 用例，甚至可能取决于他们对您的订阅。就像验证码一样，这可以减缓黑客利用您的 API 的速度，就像验证码一样，如果他们必须手动创建新的用户帐户来创建新的 API 密钥。

![Monitoring API Pagination Attacks](img/94f1d23e1a20538c0694840f63c07883.png)

## 不安全的 API 密钥生成

大多数 API 都受到某种 API 密钥或 JWT (JSON Web Token)的保护。这提供了一种自然的方法来跟踪和保护您的 API，因为 API 安全工具可以检测异常的 API 行为，并自动阻止对 API 密钥的访问。然而，黑客想要通过从大量用户生成和使用大量 API 密钥来胜过这些机制，就像网络黑客会使用大量 IP 地址来规避 DDoS 保护一样。

### 如何保护 API 密钥池

防范这些类型攻击的最简单方法是要求用户注册您的服务并生成 API 密钥。Bot 流量可以通过验证码和双因素身份验证来阻止。除非有合法的商业案例，否则注册您的服务的新用户不应该有以编程方式生成 API 密钥的能力。相反，只有受信任的客户应该能够以编程方式生成 API 密钥。更进一步，确保针对异常行为的任何异常检测都是在用户和帐户级别完成的，而不仅仅是针对每个 API 键。

## 意外钥匙暴露

API 的使用方式增加了凭据泄露的可能性:

1.  API 预计会被无限期地访问，这增加了黑客获得未过期的有效 API 密钥的可能性。您将 API 键保存在一个服务器环境变量中，然后忘记它。这与用户登录交互式网站形成了鲜明的对比，在交互式网站上，会话在短时间内就会过期。
2.  API 的消费者可以直接访问凭证，比如在通过 Postman 或 CURL 进行调试时。只需要一个开发人员不小心将包含 API 密钥的 CURL 命令复制/粘贴到一个公共论坛，就像 GitHub 问题或堆栈溢出一样。
3.  API 密钥通常是不需要任何其他标识信息的不记名令牌。API 不能利用诸如一次性令牌或双因素身份验证之类的东西。

如果一个密钥由于用户错误而暴露，人们可能会认为你作为 API 提供者有任何责任。然而，安全性就是减少表面积和风险。像对待自己的数据一样对待您的客户数据，并通过添加防护措施来防止意外的密钥泄露来帮助他们。

### 如何防止意外的按键暴露

防止密钥泄露的最简单方法是利用两个令牌，而不是一个。一个*刷新令牌*被存储为一个环境变量，并且只能用于生成*短期访问令牌*。与刷新令牌不同，这些短期令牌可以访问资源，但有时间限制，如几小时或几天。

客户将与其他 API 密钥一起存储刷新令牌。然后，您的 SDK 将在 SDK init 上或在最后一个访问令牌过期时生成访问令牌。如果一个 CURL 命令被粘贴到 GitHub 问题中，那么黑客需要在几个小时内使用它来减少攻击媒介(除非它是实际的刷新令牌，这种可能性很低)

## 暴露于 DDoS 攻击

API 开启了全新的业务模型，客户可以通过编程访问您的 API 平台。然而，这可能会使 DDoS 保护变得棘手。大多数 DDoS 保护被设计为在 DDoS 攻击期间吸收和拒绝来自不良参与者的大量请求，但是仍然需要让好的参与者通过。这需要对 HTTP 请求进行指纹识别，以检查看起来像 bot 流量的内容。对于 API 产品来说，这要困难得多，因为所有的流量看起来都像是僵尸流量，而不是来自存在 cookies 之类东西的浏览器。

### 阻止 DDoS 攻击

API 的神奇之处在于，几乎每次访问都需要一个 API 密钥。如果一个请求没有 API 键，您可以自动拒绝它，这在您的服务器上是轻量级的(确保在稍后的中间件(如请求 JSON 解析)之前很早就将身份验证短路)。那么，如何处理经过身份验证的请求呢？最简单的是利用每个 API 键的速率限制计数器，例如每分钟处理 X 个请求，并使用`429 HTTP response.`拒绝那些高于阈值的请求。有多种算法可以做到这一点，例如漏桶和固定窗口计数器。

## 不正确的服务器安全性

就良好的服务器卫生而言，API 与 web 服务器没有什么不同。由于 SSL 证书配置错误或允许非 HTTPS 流量，数据可能会泄露。对于现代应用程序，几乎没有理由接受非 HTTPS 请求，但是客户可能会错误地从他们的应用程序发出非 HTTP 请求，或者暴露 API 密钥的 CURL。API 没有浏览器的保护，所以像 HSTS 或重定向到 HTTPS 这样的东西不提供保护。

### 如何确保正确的 SSL

在 Qualys SSL Test 或类似工具上测试您的 SSL 实现。您还应该阻止所有可以在负载平衡器中完成的非 HTTP 请求。您还应该删除任何 HTTP 头，清除任何泄露实现细节的错误消息。如果您的 API 仅由您自己的应用程序使用，或者只能在服务器端访问，那么查看【REST APIs 跨源资源共享权威指南

## 不正确的缓存头

API 提供对每个 API 键范围内的动态数据的访问。任何缓存实现都应该能够限制 API 键的范围，以防止交叉污染。即使您没有在基础架构中缓存任何东西，您也可能会让您的客户暴露于安全漏洞之下。如果拥有代理服务器的客户使用多个 API 键，比如一个用于开发，一个用于生产，那么他们可以看到交叉混合的数据。

这有多严重？[见数据安全事件后推特披露账单信息泄露](https://www.bleepingcomputer.com/news/security/twitter-discloses-billing-info-leak-after-data-security-incident/)

### 如何确保没有缓存

您应该确保正确配置了[缓存控制](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control)头。

API 的一个大问题是许多 API 不使用标准的`Authorization`头，而是使用像`X-Api-Key`这样的自定义头。缓存服务器不知道这个请求正在被认证，因此选择缓存该请求。

```py
app.use((req, res, next) => {
  res.setHeader('Cache-Control', 'no-store, no-cache, must-revalidate');
  res.setHeader('Pragma', 'no-cache');
  // ...
}); 
```

## 记录和监控不足

这是 OWASP 十大 API 安全项目。大多数违规研究表明，检测数据违规的时间超过 200 天。如果您没有适当的 API 日志和监控，攻击者可以继续使用相同的漏洞，甚至探测更多的漏洞。

### 如何正确添加 API 日志记录

您应该确保您的 API 日志记录不仅跟踪 API 请求本身，还与用户相关联，用于*用户行为分析*，并至少保存一年。这些系统应受到保护，以确保数据不会被意外删除或提前停用。出于安全目的，GDPR 和 CCPA 为 API 审计日志提供了例外。像 [Moesif API Security](https://www.moesif.com/solutions/api-security) 这样的解决方案为 API 产品提供了一整套 API 监控和分析，只需几分钟就可以开始使用。

![API Audit Log](img/5f4790b5fdb4afe34ae64eb9c7d3590a.png)

## 不保护内部端点

同一个 API 服务可能有外部使用和外部使用的端点。仅仅因为端点没有被记录并不意味着黑客不能调用它。除了使用身份验证和授权方案进行保护之外，您还应该确保这些端点根本不会暴露给公共互联网，这可以在您的负载平衡器或 API 网关中完成。这有助于提供多种安全级别，这是一种常见的预防策略。

## 不处理授权

虽然大多数 API 开发者会添加一个全局的*认证*方案，比如 API keys 或 OAuth 来验证这个人是谁，但是实现*授权*就更难了，授权也是必需的，并且与认证分开。授权包括检查这个人(已经确定)是否可以访问特定的资源。这可以通过 API 作用域来完成，检查租户 id 或用户 id，等等。

因为它特定于您的应用程序逻辑，并且不总是交叉的，所以授权可能是开发人员忘记的一个领域。除非您的对象标识符有足够的熵，否则黑客可以很容易地通过迭代测试不同的 id。对于在插入时增加 id 的 SQL 数据库来说尤其如此。

### 如何修复授权

确保经过身份验证的用户有权访问生成 API 响应所需的所有资源。这可能涉及到检查链接到相关对象的用户 id 或访问控制列表(ACL)。关于如何处理授权的更多信息，请查看我们的帖子[为 RESTful APIs 构建认证和授权的步骤](/blog/technical/restful-apis/Authorization-on-RESTful-APIs/)
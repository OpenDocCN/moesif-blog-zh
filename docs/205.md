# 每个 CRUD 应用程序使用哪个 HTTP 状态代码

> 原文：<https://www.moesif.com/blog/technical/api-design/Which-HTTP-Status-Code-To-Use-For-Every-CRUD-App/>

HTTP 规范定义了许多我们在响应客户时可以使用的状态代码。有些 API 只使用最基本的代码，并在其上定义自己的错误信号机制；其他人希望充分利用 HTTPs 代码集合来告诉他们的客户端发生了什么。如果你属于后者，这篇文章适合你。本指南介绍了各种 CRUD 操作，以及在干净的 API 设计中应该使用哪些状态代码。

## HTTP 状态代码

状态代码是一个大于 100 小于 600 的数字，是 HTTP 响应的一部分。第一个数字定义了状态的类别。状态代码带有一个原因短语。代码是为了程序识别，短语是为了让人们理解发生了什么。

每个状态代码都必须遵循这两条规则，甚至是自定义规则(是的，状态代码是可扩展的)。

## 状态类别

如果我们了解 a 类状态代码，我们可以更快地定位问题。

### 100 - 199

这些是信息状态代码；它们通常告诉客户端，请求的报头部分已经收到，服务器将尝试遵从客户端的传输要求。比如使用不同的协议，或者在开始发送消息体之前告诉客户端它的请求会失败。

### 200 - 299

这些是成功的密码。他们告诉客户它的请求被接受了。在异步处理请求(202)的情况下，这并不意味着请求被成功处理，只是说它满足发送时的所有验证要求。

### 300 - 399

这些是重定向代码。他们告诉客户端，他们请求的资源在预期的位置不再可用。这可能有多种原因，可能是暂时的，也可能是永久的，但客户端必须向新位置发出请求。

### 400 - 499

这些是客户端错误代码。它们都是关于客户端发送给服务器的无效请求。这有几个原因，超时，错误的 URI，错过认证等。客户端正在发送不正确的输入，应在重试请求之前确认输入参数是否正确。

### 500 - 599

这些是服务器错误代码。它们通常表示服务器过载或代理后面的服务器不可达的问题，但有时它们可能与触发服务器上错误异常的客户端请求直接相关。这些错误可能是暂时的，也可能是永久的。通常，客户端最好重试相同的请求。

### 自定义类别

自定义类，即 599 以上的类是不允许的，但仍被一些服务使用。对于 API 设计者来说，它们是相关的坏例子。然而，API 客户机创建者必须处理它们。

因此，虽然通常不允许，但要做好在野外遇见它们的准备。

## CRUD(创建、读取、更新、删除)

[CRUD 模型](https://en.wikipedia.org/wiki/Create,_read,_update_and_delete)为持久存储定义了最基本的 API 动作。创建、读取、更新和删除。它们构成了 API 端点的最大部分。让我们看看哪些状态代码符合他们的要求。

## 创造

创建动作通常通过 HTTPs `POST`方法实现。在 RESTful APIs 中，这些端点用于创建新资源或访问令牌。

**状态代码**

*   这是告诉客户一切顺利的基本状态代码。因为我们在创建访问令牌时没有创建端点可访问资源，所以我们可以使用 200 作为该操作的状态。
*   **201 创建了**——最适合创建操作。这段代码应该发出后端资源创建的信号，并附带一个`Location`头，为新创建的资源定义最具体的 URL。在响应体中包含资源的适当表示或者至少一个或多个资源的 URL 也是一个好主意。
*   **202 已接受** -常用于**异步**处理。这段代码告诉客户端请求是有效的，但是它的处理将在未来的某个时候完成。响应体应该包含一个指向已完成资源的 URL，其中包含一些关于资源何时可用的信息，或者包含一个指向某个监控端点的 URL，该端点会告知客户端资源何时可用。
*   **303 参见其他**——类似于 202 代码，但是使用`Location`头字段来响应通知客户端关于所创建的资源的位置或端点，该端点允许客户端检查创建过程的状态。一些客户端会自动跟踪重定向类的状态代码。这个代码通常只用于`POST`请求。

## 阅读

read 动作通过 HTTPs `GET`方法实现，并用于获取资源表示。异步响应在这里并不重要，因为异步处理的原因通常是资源还不存在，需要创建，所以无论如何这是一个创建操作。

**状态代码**

*   **200 OK** -大部分读取动作将会以 200 OK 状态回答。
*   **206 部分内容**——这个代码对于太大而无法在一次响应中交付的内容列表非常有用。它必须与请求中的`Range`头字段一起使用。通常，这个头字段定义了后端应该发送给客户端的字节范围，但是只要双方都理解，这个单位可以自由分配。
*   **300 多项选择**——如果一个资源有多个表示，并且客户端(或其用户)必须选择其中一个，那么就使用这个重定向。
*   **308 永久重定向**——这告诉客户端使用另一个 URL 来访问资源，并且不再使用当前的 URL。当一个资源有多个端点，但不想实现从所有端点读取时，这很有帮助。
*   **304 未修改**——像 200 一样使用，但没有主体，所以客户端将从先前的读取被*重定向*到其本地缓存的表示。
*   **307 临时重定向**——当资源的 URL 在未来可能改变时，客户端应该在访问真实的 URL 之前询问当前的 URL。

## 更新

可以用 HTTP `PUT`或`PATCH`方法实现更新。区别在于客户端必须发送到后端的数据量。

要求客户端发送一个完整的资源表示来更新它。(用新的替换旧的)

`PATCH`要求客户端只发送资源的部分表示来更新它。(在旧版本中添加、更新或删除这些部分)

**状态代码**

*   200 OK -这是最适合大多数用例的代码。
*   204 无内容(No Content)204 无内容(No Content)204 无内容更新(No Content)204 无内容更新(No Content)204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 无内容更新 204 客户端，例如当保存当前编辑的文档时。
*   **202 接受** -如果更新是异步完成的，可以使用这个代码。它应该包括一个访问更新资源的 URL 或一个检查更新是否成功的 URL。它还可以包括对更新所需时间的估计。

## 删除

删除操作可以用 HTTP `DELETE`方法实现。

**状态代码**

*   有些人认为任何类型的删除函数都应该返回被删除的元素，所以被删除元素的表示可以包含在响应体中。
*   **204 无内容** -最适合这种情况的状态代码。最好是减少流量，简单地告诉客户端删除完成，不返回响应体(因为资源已经被删除)。
*   **202 Accepted**——如果删除是异步的，并且需要一些时间，这是分布式系统的情况，适当的做法是返回这个带有一些信息或 URL 的代码，告诉客户端它什么时候会被删除。

## API 变更

如果我们的 API 存在足够长的时间，它迟早会改变它的结构。最好的做法是避免中断更改，状态代码的重定向类可以对此有所帮助，因为一些客户端会自动跟随它们的`Location`头。

**状态代码**

*   307 临时重定向(Temporary Redirect)——如果将来资源可以在不同的 URL 上使用，这是正确的代码，但是我们希望当前的端点控制客户端重定向到哪里。这个状态代码将让客户端为每个请求返回到当前的 URL。
*   **308 永久重定向** -如果资源现在可以在新的 URL 上使用，并且客户端将来应该通过新的 URL 直接访问它，那么这就是正确的代码。当前端点无法控制请求后的客户端行为，如果资源 URL 再次更改，则必须从新的 URL 发出后续重定向。

### 一个资源有多个端点

如果我们选择在我们的 API 中使用嵌套或子资源，那么只从根(非嵌套)资源交付表示将有助于保持实现的干燥。重定向状态代码对此有所帮助。

**状态代码**

*   **308 永久重定向**——如果我们有嵌套资源`/user/kay/comments/456`和`/posts/123/comments/456`；和根资源`/comments/456`它可以使事情变得更容易，只需在嵌套资源中发出 308 重定向，其中`Location`头字段指向根资源，因此不是每个端点都需要交付实现。这应该只针对`GET`的请求。

## 错误

API 的下一个重要部分是它的错误。许多 API 框架在出错时默认使用 500 和 404 状态代码，但是根据具体情况，通常会有更多的描述性代码。

500 表示*内部服务器错误*，这可能是后端访问时没有检查其存在而丢失的头字段，也可能是后端想要调用的无法到达的第三方服务。

因此，可能是客户端做错了什么，我们会期待一个 400-499 的状态代码，但后端从来没有尝试验证请求，并试图处理它，即使它是无效的，我们最终与服务器错误。

404 表示*未找到*。这可能是因为客户端使用了一个错误的 URL 指向一些没有在后端正确设置的端点。

正如我们看到的，404 是一个客户端错误状态代码，但它很可能是我们在后端做错了什么。

### 错误的 URL

当客户端发送一个 URL 时，我们不知道。这可能有多种不同的原因，因此我们必须检查哪一种原因适用于此处。

**状态代码**

*   **404 未找到** -这是最自然的反应，应该在客户端 URL 错误的情况下使用。
*   不允许使用 405 方法——在许多框架中，我们在 HTTP 方法旁边定义了 URL，因此删除其中一个定义会使一个 URL 的所有方法保持不变，只留下一个。响应必须包括一个列出允许做什么的`Allow`头字段。
*   **501 没有实现**——像 405 一样，但是后端的所有资源都缺少该方法。
*   **406 不可接受**-URL 存在，但后端无法发送客户端将接受的表示。因此，对于特定的客户端，URL 的行为类似于 404，但是他们现在知道他们需要更新客户端。
*   410 消失了，这就像 404，但是我们知道资源在过去存在，但是它被删除了或者不知何故被移动了，我们不知道它在哪里。
*   **414 请求-URI 太长** -当端点是正确的，并且资源存在，但是查询使 URL 太长而无法解释时，有时会出现这种情况。
*   308 永久重定向(Permanent Redirect)——如果我们知道一个资源已经移动到了一个不同的 URL，并且我们可以告诉客户端，那么这将是正确的代码。
*   **307 临时重定向**——和 308 一样，但是我们不知道将来资源是会回到原来的 URL 还是另一个不同的 URL。

### 没有权限

通常客户端不能访问后端的所有资源，所以我们需要一种方式来告诉他们。

**状态代码**

*   **401 未授权** -客户端还没有授权自己访问后端，服务器可能会在授权之后授予它访问权限。
*   **403 禁止** -客户端已经授权或者不需要授权自己，但是仍然没有访问资源的权限。
*   **404 未找到** -如果 401 或 403 是这种情况，但后端出于安全原因不想告诉客户端该资源存在。

## 结论

HTTP 的创建者在设计它的时候考虑了许多状态代码，甚至在过去的几年里添加了许多新的状态代码。如果正确使用它们，它们可以通过利用客户端的自动重定向跟踪和更清楚地解释发生了什么来帮助极大地改善开发人员的体验。

有时我们可以为一个特定的情况使用多个代码，重要的是我们在整个 API 表面上保持使用的一致性。
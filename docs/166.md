# 如何最好地监控 GraphQL APIs

> 原文：<https://www.moesif.com/blog/technical/monitoring/How-to-Best-Monitor-GraphQL-APIs/>

自 2015 年发布以来，GraphQL 已经成为 REST 的第**种选择。它给前端开发人员带来了他们渴望已久的灵活性。**

向后端开发人员乞求单一目的端点的日子已经过去了。现在，一个查询可以定义所有需要的数据并一次性请求，至少在理论上大大减少了延迟。

有了 REST，事情就完全简单了——尤其是监控。后端团队可以查看每个端点的测量结果，并立即了解正在发生的情况。

有了 GraphQL，情况就不一样了。通常只有一个端点，因此测量每个端点没有太大帮助。那么，有哪些新的地方可以接入系统呢？

在本文中，我们研究如何监控 GraphQL！

## GraphQL 架构

为了了解**我们系统中的**有趣点在哪里，让我们看看潜在的架构。

一个简单的 GraphQL 系统主要由三部分组成:

1.  定义所有数据类型的模式
2.  一个 GraphQL 引擎，它使用模式将查询的每个部分路由到解析器
3.  一个或多个解析器，它们是由 GraphQL 引擎调用的函数

GraphQL 后端从解析模式开始，这为服务器提供了关于哪个解析器处理哪个类型的知识。

当我们向 GraphQL 端点发送查询时，它会被引擎解析，对于查询中请求的每个类型，引擎都会调用我们的解析器来满足请求。

正如我们所想象的，这种方法只有在用于简单查询时才能提供出色的性能。

有时，查询的各个部分可以在我们的数据源中相互连接(数据源意味着类似数据库或第三方 API 的东西)。例如，我们正在加载一个用户帐户及其地址。它们在 GraphQL 模式中可能是两种类型，但在数据源中仅仅是一个记录。如果我们一次请求两个，我们不会期望服务器向数据源发出两个请求。

为了解决这个问题，人们开始使用一种叫做**数据加载器**的模式。

数据加载器是 GraphQL API 中的另一层，位于解析器和数据源之间。

在简单的设置中，解析器将在更复杂的迭代中直接访问数据源，解析器将告诉数据加载器它们需要什么，这个加载器将为它们访问数据源。

为什么这有帮助？

数据加载器可以等待，直到所有解析器都被调用，并合并对数据源的访问。

有人想加载用户帐户和地址吗？这只是对数据源的一个请求！

这个想法是，解析器只知道它的需求，数据加载器知道所有解析器想要什么，并且可以优化访问。

## 监控图表 QL

正如我们所看到的，根据我们的架构，我们可以在多个地方监控我们的 GraphQL API。

1.  **HTTP 端点**

*   对于所有访问我们 API 的流量

1.  **GraphQL 查询**

*   对于每个特定的查询

1.  **图 QL 解析器或数据加载器**

*   对于对数据源的每次访问

1.  **追踪**

*   在每个查询之后，它们会影响解析器和数据加载器

## 1.HTTP 端点

HTTP 端点就是我们监控的 REST API。在 GraphQL 世界中，通常只有一个，所以这个级别的监控只能给我们提供关于 API 整体状态的信息。

这还不错。至少它给了我们一个起点。如果一切正常，低延迟、低错误率、无客户投诉、一切都是绿色的，那么我们只需查看这些指标就可以节省时间和金钱。

如果有什么不对劲，我们需要深入挖掘。

## 2.GraphQL 查询

下一个明显的步骤是查看每个查询，这对于具有静态使用模式的 API 来说已经足够好了。

如果我们只对自己的客户使用我们的 API，通常很明显查询不会经常改变，但是如果我们的 API 适用于具有不同需求的不同客户，事情就不再那么简单了。

突然之间，我们可能会有数百个(稍微)不同的查询，它们都因为这样或那样的原因而运行缓慢。

解决这个问题的一个方法是检查最常见的查询，并尝试综合监控它们。这意味着我们定义一堆查询和变量组合，并从测试客户端运行它们，当我们推出新版本时，测试客户端会检查它们需要多长时间。通过这种方式，我们可以降低更新造成显著性能退化的风险。[持久化查询](https://blog.apollographql.com/persisted-graphql-queries-with-apollo-client-119fd7e6bba5)可以对此有所帮助。它们是缓存最常用查询的一种方式。

如果事情超出了我们的能力，我们需要采取另一个步骤。

## 3.解析器和数据加载器

监控发生了什么的最佳地点通常是橡胶接触路面的地方。如果我们看看后端访问数据源的地方，我们可以更好地把握现实。

我们使用的数据源类型仅仅是访问模式的错误吗？我们需要不同类型的数据库吗？

我们的数据源类型可以吗，但是我们应该提高对它们的要求？如果我们还没有使用数据加载器,我们还需要这样的东西吗？

我们是否向太慢的外部 API 发送请求？我们能在离后端更近的地方复制这些数据吗？

现在，当我们看到在我们的后端检索数据的内容和方式时，所有这些问题都可以问了。

这里我们还看到了数据加载器的另一个好处。解析器只允许我们监视一个解析器做什么；数据加载器允许我们看到所有解析器在一个请求中做了什么，另外还允许我们在发现问题后解决解析器间的问题。

## 4.跟踪整个堆栈

这是监控的最高纪律。当查询传入时，用 tracing-ID 标记查询，当查询被转换为解析器、数据加载器甚至数据源时，传递这个 ID。这允许我们在记录计时和错误时使用 tracing-ID，因此我们可以在以后合并它们以获得更大的视图。

这里的想法如下:

虽然测量一个查询可能会给我们一些关于解析所需时间的数据，但是实际的数据加载是在解析器和/或数据加载器中完成的，而不是在解析查询时完成的。

在加载数据时，我们不再使用查询，因为 GraphQL 的核心思想之一是将查询从实际的数据加载中分离出来，但是当有人发送查询时，看到后台发生的事情仍然很有趣。

## 结论

了解 GraphQL API 的后端是如何构建的，可以让我们更好地了解在哪里监控这样的系统。

与 REST APIs 相比，事情确实变得有些麻烦，但是 GraphQL API 中并没有什么神奇的事情发生，它只是我们可以为了不同的目的(比如监控)而挂接的代码。

如果我们在生产系统中获得可见性，关于缓存和错误处理的问题也会变得更加清楚。